#!/usr/bin/ruby
# Copyright (C) Thomas Chace 2011-2013 <tchacex@gmail.com>
# This file is part of Post.
# Post is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Post is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public License
# along with Post.  If not, see <http://www.gnu.org/licenses/>.

require('rubygems')
require('post')
require('optparse')
require('fileutils')
require('yaml')

STDOUT.sync = true
PWD = Dir.pwd()
CONFIG = YAML::load_file("/etc/post/config")
LOGFILE = File.open("/var/log/post.log", "a")
OPTIONS = {}
OPTIONS[:root] = CONFIG["root"]
DATA = PackageDataBase.new()
DATA.set_root(OPTIONS[:root])

def array_to_string(array)
    list_string = ""
    array.each { |item| list_string += "#{item.to_s} " }
    return list_string
end

def puts(x, stdout = true)
    ## Lets us write to logs and to stdout if we choose.
    message = "#{Time.now}: #{x}"
    LOGFILE.puts(message)
    if (stdout)
        print("#{x}")
    end
end

## Updating the package database
#puts("Loading:     Downloading package information.\n")
UPDATE = Thread.new() {
    begin
        DATA.update_database()
    rescue
    end
}

def get_plugin(symbol)
    ## Loads a plugin providing a certain method.
    Plugin.plugins.each do |plugin|
        plugin = plugin.new(OPTIONS[:root], DATA)
        if plugin.respond_to?(symbol)
            return plugin
        end
    end
end

def confirmation(queue)
    ## Simple function to confirm an operation on a given queue with the user.
    return false if queue.empty?
    puts("Queue:       #{queue.to_a.join(" ")}\n")
    puts('Confirm:     [y/n] ')
    return true if gets.include?('y')
end

def install_local_packages(args)
    UPDATE.join
    ## Copies files over to a working directory and installs them.
    args.each do |package|
        path = File.join(File.expand_path(PWD), package)
        FileUtils.cp(path, "/tmp/post/#{File.basename(path)}")
    end
    if confirmation(args)
        args.each { |package| get_plugin(:install_package).do_install(File.basename(package)) }
    end
end

def install_source_packages(args)
    UPDATE.join
    ## Fetches from a remote location(partition, server, or otherwise) and 
    ## installs a list of packages and their dependencies.
    queue = PackageList.new()

    begin
        args.each { |package| queue.push(package) }
        if confirmation(queue)
            queue.each do |package|

                ## Fetches a package.
                puts("Building:    Fetching pstbuild file.\n")
                get_plugin(:fetch_build).fetch_build(package)
            end
            queue.each do |package|
                ## Separated just to insure sanity and avoid partial upgrades.
                ## Installs a package.
                puts("Building:    Getting source code.\n")
                get_plugin(:build_package).get_source(package)
                puts("Building:    Making package.\n")
                get_plugin(:build_package).build_package(package)
                puts("Installing:  #{package}\n")
                get_plugin(:install_package).install_package(package)
            end

        end
    rescue MismatchedHash => error
        puts("#{error.message}\n")
    rescue ConflictingEntry => error
        puts("#{error.message}\n")
    end
end

def install_packages(args)
    UPDATE.join
    ## Fetches from a remote location(partition, server, or otherwise) and 
    ## installs a list of packages and their dependencies.
    queue = PackageList.new(DATA)

    begin
        args.each { |package| queue.push(package) }
        if confirmation(queue)
            queue.each do |package|
                ## Fetches a package.
                get_plugin(:fetch_package).fetch_package(package)
                ## Verifies that all packages have been acquired without corruption
                puts("Verifying:   #{package}\n")
                get_plugin(:verify_package).verify_package(package)
            end
            queue.each do |package|
                ## Separated just to insure sanity and avoid partial upgrades.
                ## Installs a package.
                puts("Installing:  #{package}\n")
                get_plugin(:install_package).install_package(package)
            end

        end
    rescue MismatchedHash => error
        puts(error.message)
    rescue ConflictingEntry => error
        puts(error.message)
    end
end

def remove_packages(args)
    queue = []
    args.each do |package|
        queue.push(package) if DATA.installed?(package)
        for pkg in DATA.get_installed_packages()
            if DATA.get_installed_data(pkg)['dependencies'].include?(package)
                queue.push(pkg)
            end
        end
    end
    if confirmation(queue)
        queue.each { |package| puts("Removing:    #{package}\n") }
        queue.each { |package| get_plugin(:remove_package).remove_package(package) }
    end
end

options = ARGV.options()
options.set_summary_indent('    ')
options.banner =    "Usage: post [OPTIONS] [PACKAGES]"
options.version =   "Post 2.5 (2.4.6)"
options.define_head "Copyright (C) Thomas Chace 2011-2013 <tchacex@gmail.com>"

#### Package management options.

options.on( '--root=OPT', String, "Change the root filesystem." ) do |arg|
        OPTIONS[:root] = arg
        DATA.set_root(OPTIONS[:root])
        DATA.update_database()
    end
options.on('-i', '--fetch PACKAGES', Array,
    'Install a package.')  { |args| install_packages(args) }
options.on('-s', '--source PACKAGES', Array,
    'Install a source package.')  { |args| install_source_packages(args) }
options.on('-l', '--install PACKAGES', Array,
    'Install a local package.')  { |args| install_local_packages(args) }
options.on('-r', '--remove PACKAGES', Array,
    'Remove a package.') { |args| remove_packages(args) }
options.on('-u', '--upgrade',
    'Upgrade packages to latest versions') do
        packages = DATA.get_installed_packages()
        install_packages(packages)
    end

options.separator("")
    
#### Database options.

options.on('--depends PACKAGE', String,
    'Get dependencies.')  do |arg|
        if DATA.available?(arg)
            print("#{array_to_string(DATA.get_sync_data(arg)['dependencies'])}\n")
        end
    end
options.on('--version PACKAGE', String,
    'Get latest version.') do |arg|
        if DATA.available?(arg)
            print("#{array_to_string(DATA.get_sync_data(arg)['version'])}\n")
        end
    end
options.on('--conflicts PACKAGE', String,
    'Get conflicting packages.')  do |arg|
        if DATA.available?(arg)
            print("#{array_to_string(DATA.get_sync_data(arg)['conflicts'])}\n")
        end
    end
options.on('--description PACKAGE', String,
    'Get package description.')  do |arg|
        print("#{DATA.get_sync_data(arg)['description']}\n") if DATA.available?(arg)
    end
options.on('--files PACKAGE', String,
    'Get installed files.')  do |arg|
        if DATA.available?(arg)
            print(array_to_string(DATA.get_files(arg)))
        end
    end

options.on('--availablepackages',
    'Get available packages.')  do
        print("#{array_to_string(DATA.get_available_packages)}\n")
    end
options.on('--packages',
    'Get installed packages.')  do
        print("#{array_to_string(DATA.get_installed_packages)}\n")
    end

options.on('-h', '--help', 'Show this help message.') { puts(options) }
options.on('-v', '--version', 'Show version information.') { puts("#{options.version()}\n") }
options.parse!
